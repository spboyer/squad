const { describe, it, beforeEach, afterEach } = require('node:test');
const assert = require('node:assert/strict');
const fs = require('fs');
const path = require('path');
const { execFileSync } = require('child_process');
const os = require('os');

const CLI = path.join(__dirname, '..', 'index.js');

function runSquad(args, cwd) {
  try {
    const result = execFileSync(process.execPath, [CLI, ...args], {
      cwd,
      encoding: 'utf8',
      timeout: 15000,
      env: { ...process.env, NO_COLOR: '1' },
    });
    return { stdout: result, exitCode: 0 };
  } catch (err) {
    return {
      stdout: (err.stdout || '') + (err.stderr || ''),
      exitCode: err.status ?? 1,
    };
  }
}

function makeTempDir() {
  return fs.mkdtempSync(path.join(os.tmpdir(), 'squad-init-flow-test-'));
}

function cleanDir(dir) {
  try {
    fs.rmSync(dir, { recursive: true, force: true });
  } catch {}
}

function initSquad(dir) {
  const result = runSquad([], dir);
  assert.equal(result.exitCode, 0, `init should succeed: ${result.stdout}`);
  return result;
}

// Read the generated squad.agent.md from an initialized temp dir
function readGeneratedAgent(dir) {
  const agentPath = path.join(dir, '.github', 'agents', 'squad.agent.md');
  assert.ok(fs.existsSync(agentPath), 'squad.agent.md should exist after init');
  return fs.readFileSync(agentPath, 'utf8');
}

// Extract ALL Init Mode sections from squad.agent.md (handles two-phase split)
function extractInitMode(content) {
  // Match either "## Init Mode" or "## Init Mode — Phase 1" as the start
  const phase1Match = content.match(/## Init Mode[^\n]*/);
  assert.ok(phase1Match, 'squad.agent.md should contain an Init Mode heading');
  const initStart = phase1Match.index;

  // Find Phase 2 if it exists, and include it
  const phase2Match = content.indexOf('## Init Mode — Phase 2');
  if (phase2Match !== -1) {
    // Find the next non-Init-Mode ## heading after Phase 2
    const afterPhase2 = content.indexOf('\n## ', phase2Match + 22);
    return afterPhase2 !== -1
      ? content.slice(initStart, afterPhase2)
      : content.slice(initStart);
  }

  // Single-section fallback
  const afterStart = content.indexOf('\n## ', initStart + 12);
  return afterStart !== -1
    ? content.slice(initStart, afterStart)
    : content.slice(initStart);
}

describe('Init Mode prompt structure (#66)', () => {
  let tmpDir;

  beforeEach(() => {
    tmpDir = makeTempDir();
  });

  afterEach(() => {
    cleanDir(tmpDir);
  });

  describe('init creates squad.agent.md with Init Mode section', () => {
    it('squad.agent.md is generated by init', () => {
      initSquad(tmpDir);
      const agentPath = path.join(tmpDir, '.github', 'agents', 'squad.agent.md');
      assert.ok(fs.existsSync(agentPath), 'squad.agent.md should exist after init');
    });

    it('generated file contains Init Mode section', () => {
      initSquad(tmpDir);
      const content = readGeneratedAgent(tmpDir);
      assert.ok(
        content.includes('## Init Mode'),
        'squad.agent.md should contain an "## Init Mode" section'
      );
    });
  });

  describe('Init Mode has explicit stop instruction', () => {
    it('Init Mode contains a STOP or WAIT gate between proposing and creating', () => {
      initSquad(tmpDir);
      const content = readGeneratedAgent(tmpDir);
      const initMode = extractInitMode(content);

      // The prompt should contain an explicit instruction to stop and wait
      // for user confirmation before creating files.
      const hasStopGate =
        /\bSTOP\b/i.test(initMode) ||
        /\bWAIT\b/i.test(initMode) ||
        /\bDO NOT (proceed|continue|create)/i.test(initMode) ||
        /\bpause\b.*\b(confirm|response|input)\b/i.test(initMode) ||
        /\bmust (wait|stop|pause)\b/i.test(initMode);

      assert.ok(
        hasStopGate,
        'Init Mode should contain an explicit STOP/WAIT instruction between proposing the team and creating files. ' +
        'Without this, LLMs will execute steps 4-6 in a single turn, skipping user confirmation.'
      );
    });
  });

  describe('Init Mode step 5 exists and contains confirmation question', () => {
    it('step 5 asks for user confirmation', () => {
      initSquad(tmpDir);
      const content = readGeneratedAgent(tmpDir);
      const initMode = extractInitMode(content);

      // Check that step 5 exists with a confirmation question
      const hasConfirmationQuestion =
        initMode.includes('Look right?') ||
        initMode.includes('look right?') ||
        /does this (look|seem) (right|good|correct)/i.test(initMode);

      assert.ok(
        hasConfirmationQuestion,
        'Init Mode step 5 should ask "Look right?" or equivalent confirmation question'
      );
    });

    it('confirmation step is numbered before file creation step', () => {
      initSquad(tmpDir);
      const content = readGeneratedAgent(tmpDir);
      const initMode = extractInitMode(content);

      // Find the step number that contains confirmation (ask_user or "Look right?")
      // Step 5 may reference ask_user with "Look right?" on a following line
      const confirmMatch =
        initMode.match(/(\d+)\.\s.*(?:Look right\?|look right\?|ask_user.*confirm)/i) ||
        initMode.match(/(\d+)\.\s.*ask_user/i);
      // Find the step number that contains creating .squad/
      // Match lines like "6. Create the `.squad/` directory structure"
      const createMatch = initMode.match(/^(\d+)\.\s.*(?:create|Create).*\.squad/m);

      assert.ok(confirmMatch, 'Should find a numbered step with confirmation question');
      assert.ok(createMatch, 'Should find a numbered step that creates .ai-team/');

      const confirmStep = parseInt(confirmMatch[1], 10);
      const createStep = parseInt(createMatch[1], 10);

      assert.ok(
        confirmStep < createStep,
        `Confirmation step (${confirmStep}) should come before file creation step (${createStep})`
      );
    });
  });

  describe('no tool calls between propose and confirm', () => {
    it('prompt does not instruct creating files in the same step as proposing', () => {
      initSquad(tmpDir);
      const content = readGeneratedAgent(tmpDir);
      const initMode = extractInitMode(content);

      // Find step 4 (propose) through step 5 (confirm) — there should be
      // no file creation instructions in between.
      const proposeMatch = initMode.match(/4\.\s+Propose/);
      const confirmMatch = initMode.match(/5\.\s+(Ask|Use)/);

      assert.ok(proposeMatch, 'Step 4 should propose the team');
      assert.ok(confirmMatch, 'Step 5 should ask for confirmation (via Ask or ask_user)');

      const betweenProposeAndConfirm = initMode.slice(
        proposeMatch.index,
        confirmMatch.index
      );

      const hasFileCreation =
        /create.*\.squad/i.test(betweenProposeAndConfirm) ||
        /mkdir/i.test(betweenProposeAndConfirm) ||
        /writeFile/i.test(betweenProposeAndConfirm) ||
        /fs\./i.test(betweenProposeAndConfirm);

      assert.ok(
        !hasFileCreation,
        'No file creation instructions should appear between proposing the team (step 4) and asking for confirmation (step 5)'
      );
    });

    it('step 6 (Phase 2) is gated on user confirmation', () => {
      initSquad(tmpDir);
      const content = readGeneratedAgent(tmpDir);
      const initMode = extractInitMode(content);

      // Phase 2 should have a trigger condition requiring user confirmation
      const hasPhase2Gate =
        /Phase 2/.test(initMode) &&
        (/Trigger.*user repl/i.test(initMode) ||
         /user repl.*confirm/i.test(initMode) ||
         /after.*confirm/i.test(initMode) ||
         /on confirmation/i.test(initMode));

      // Also accept the old single-section format
      const step6Match = initMode.match(/^6\.\s+(.+)/m);
      const step6Conditional = step6Match &&
        (/on confirmation/i.test(step6Match[1]) ||
         /after.*confirm/i.test(step6Match[1]) ||
         /create/i.test(step6Match[1]));

      assert.ok(
        hasPhase2Gate || step6Conditional,
        'Step 6 / Phase 2 should be gated on user confirmation'
      );
    });
  });

  describe('ask_user referenced in Init Mode for confirmation', () => {
    it('Init Mode instructs coordinator to use ask_user for confirmation', () => {
      initSquad(tmpDir);
      const content = readGeneratedAgent(tmpDir);
      const initMode = extractInitMode(content);

      // The prompt should tell the coordinator to use ask_user (or equivalent
      // explicit tool call) to get confirmation before proceeding.
      const hasAskUser =
        initMode.includes('ask_user') ||
        initMode.includes('askUser') ||
        /use.*ask.*tool/i.test(initMode) ||
        /\bask\b.*\band\b.*\bwait\b/i.test(initMode);

      assert.ok(
        hasAskUser,
        'Init Mode should reference ask_user (or equivalent) to ensure the coordinator ' +
        'explicitly waits for user input before creating .squad/ files'
      );
    });
  });
});

describe('Identity layer files (now.md, wisdom.md) — #107', () => {
  let tmpDir;

  beforeEach(() => {
    tmpDir = makeTempDir();
  });

  afterEach(() => {
    cleanDir(tmpDir);
  });

  it('init creates .squad/identity/now.md', () => {
    initSquad(tmpDir);
    const nowPath = path.join(tmpDir, '.squad', 'identity', 'now.md');
    assert.ok(fs.existsSync(nowPath), '.squad/identity/now.md should exist after init');
    
    const content = fs.readFileSync(nowPath, 'utf8');
    assert.ok(content.includes('updated_at:'), 'now.md should contain updated_at field');
    assert.ok(content.includes('focus_area:'), 'now.md should contain focus_area field');
    assert.ok(content.includes('What We\'re Focused On'), 'now.md should contain heading');
  });

  it('init creates .squad/identity/wisdom.md', () => {
    initSquad(tmpDir);
    const wisdomPath = path.join(tmpDir, '.squad', 'identity', 'wisdom.md');
    assert.ok(fs.existsSync(wisdomPath), '.squad/identity/wisdom.md should exist after init');
    
    const content = fs.readFileSync(wisdomPath, 'utf8');
    assert.ok(content.includes('last_updated:'), 'wisdom.md should contain last_updated field');
    assert.ok(content.includes('Team Wisdom'), 'wisdom.md should contain heading');
    assert.ok(content.includes('## Patterns'), 'wisdom.md should contain Patterns section');
    assert.ok(content.includes('## Anti-Patterns'), 'wisdom.md should contain Anti-Patterns section');
  });

  it('upgrade creates missing identity files', () => {
    // First init
    initSquad(tmpDir);
    
    // Modify squad.agent.md to simulate an old version
    const agentPath = path.join(tmpDir, '.github', 'agents', 'squad.agent.md');
    let agentContent = fs.readFileSync(agentPath, 'utf8');
    agentContent = agentContent.replace(/<!-- version: [^>]+ -->/, '<!-- version: 0.4.0 -->');
    agentContent = agentContent.replace(/- \*\*Version:\*\* [0-9.]+(?:-[a-z]+)?/, '- **Version:** 0.4.0');
    fs.writeFileSync(agentPath, agentContent);
    
    // Delete identity files to simulate old installation
    const identityDir = path.join(tmpDir, '.squad', 'identity');
    fs.rmSync(identityDir, { recursive: true, force: true });
    
    // Run upgrade
    const result = runSquad(['upgrade'], tmpDir);
    assert.equal(result.exitCode, 0, `upgrade should succeed: ${result.stdout}`);
    
    // Check files were created - upgrade creates them because directory creation happens every time
    const nowPath = path.join(tmpDir, '.squad', 'identity', 'now.md');
    const wisdomPath = path.join(tmpDir, '.squad', 'identity', 'wisdom.md');
    
    // The directory is created, and files are scaffolded if missing
    assert.ok(fs.existsSync(identityDir), 'upgrade should create identity directory');
    assert.ok(fs.existsSync(nowPath), 'upgrade should create missing now.md');
    assert.ok(fs.existsSync(wisdomPath), 'upgrade should create missing wisdom.md');
  });
});
