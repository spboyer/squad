# Proposal 011: Forwardability and Upgrade Path

**Status:** Approved ✅ Shipped — upgrade subcommand shipped; full plan tracked in Proposal 019. Note: references `@bradygaster/create-squad`; distribution is now GitHub-only via `npx github:bradygaster/squad` per Proposal 019a.  
**Authored by:** Fenster (Core Dev)  
**Date:** 2026-02-08  
**Requested by:** bradygaster

---

## Summary

Squad has a forwardability problem. If we ship a better `squad.agent.md`, existing users never get it. The installer skips files that already exist:

```javascript
if (fs.existsSync(agentDest)) {
  console.log(`squad.agent.md already exists — skipping`);
}
```

This was the right call for v0.1 — don't clobber user state. But it blocks upgrades entirely. We need `npx create-squad upgrade` that brings existing installs forward without destroying what users have built.

Brady's words: *"any change to Squad needs to be 'forwardable' — meaning, if we update Squad with awesome features, customers should be able to update their squads with those features."*

Also: *"we don't need to stay with any decisions we've made tech-wise. none. we're fast."*

This proposal defines the complete upgrade system: what gets updated, what's protected, how versions are tracked, how migrations run, and what happens when things go wrong.

---

## The File Ownership Model

Every file Squad touches falls into one of three categories:

### Squad-Owned (overwrite on upgrade)

These files are Squad infrastructure. Users shouldn't customize them. Upgrade replaces them unconditionally.

| File | Why it's Squad-owned |
|------|---------------------|
| `.github/agents/squad.agent.md` | The coordinator spec. This IS the product. |
| `.ai-team-templates/*` | Format guides shipped by Squad. |

### User-Owned (never touch)

These files belong to the user's team. Upgrade must never read, modify, or delete them.

| File/Directory | Why it's user-owned |
|----------------|---------------------|
| `.ai-team/agents/*/charter.md` | Agent identities customized by the team |
| `.ai-team/agents/*/history.md` | Learned knowledge — irreplaceable |
| `.ai-team/decisions.md` | Team's shared brain |
| `.ai-team/decisions/inbox/*` | Pending decisions in flight |
| `.ai-team/casting/registry.json` | Agent-to-name mappings |
| `.ai-team/casting/history.json` | Universe usage history |
| `.ai-team/casting/policy.json` | User-configured casting rules |
| `.ai-team/orchestration-log/*` | Audit trail |
| `.ai-team/log/*` | Session archives |
| `.ai-team/team.md` | Generated by coordinator, user-customized |

### Additive-Only (create if missing, never overwrite)

These are files or directories that new versions may introduce. Upgrade creates them if they don't exist, leaves them alone if they do.

| File/Directory | Example scenario |
|----------------|-----------------|
| `.ai-team/casting/` | Already exists since v0.1 |
| `.ai-team/orchestration-log/` | Already exists since v0.1 |
| `skills/` | Future: v0.3 adds a skills directory |
| `.ai-team/routing.md` | Generated by coordinator, but upgrade might seed a default |

---

## Versioning Strategy

### Where the version lives

The version lives in **two places**, serving different purposes:

#### 1. `package.json` — the source of truth

```json
{
  "name": "@bradygaster/create-squad",
  "version": "0.2.0"
}
```

This is the version of Squad-the-package. npm already tracks this. The CLI reads it at runtime:

```javascript
const pkg = require(path.join(__dirname, 'package.json'));
const SQUAD_VERSION = pkg.version;
```

#### 2. `.github/agents/squad.agent.md` — embedded version stamp

A metadata comment at the top of the coordinator spec, inside the YAML frontmatter:

```yaml
---
name: Squad
description: "Your AI team. Describe what you're building, get a team of specialists that live in your repo."
squad_version: "0.2.0"
---
```

Why both? The package.json version tells the CLI "what version am I?" The squad.agent.md version tells the CLI "what version did the user install?" Comparing them answers "does this user need an upgrade?"

#### 3. `.ai-team-templates/.squad-version`

A small metadata file dropped into the templates directory:

```json
{
  "installed_version": "0.1.0",
  "installed_at": "2026-02-08T14:30:00.000Z",
  "upgraded_at": null,
  "upgrade_history": []
}
```

This is the local install receipt. The upgrade command reads it to know what version is currently installed and writes to it after a successful upgrade. It's Squad-owned — upgrade overwrites it.

### Version detection logic

```javascript
function detectInstalledVersion() {
  // Strategy 1: Read .squad-version metadata
  const versionFile = path.join(dest, '.ai-team-templates', '.squad-version');
  if (fs.existsSync(versionFile)) {
    try {
      const meta = JSON.parse(fs.readFileSync(versionFile, 'utf8'));
      return meta.installed_version;
    } catch (e) {
      // Corrupted metadata — fall through
    }
  }

  // Strategy 2: Parse squad.agent.md frontmatter
  const agentFile = path.join(dest, '.github', 'agents', 'squad.agent.md');
  if (fs.existsSync(agentFile)) {
    const content = fs.readFileSync(agentFile, 'utf8');
    const match = content.match(/^squad_version:\s*"?([^"\n]+)"?/m);
    if (match) return match[1];
  }

  // Strategy 3: If squad.agent.md exists but has no version → it's v0.1.0 (pre-versioning)
  if (fs.existsSync(agentFile)) {
    return '0.1.0';
  }

  return null; // No Squad installed
}
```

This is defensive by design. v0.1.0 installs won't have version metadata, so we infer from the presence of `squad.agent.md` without a version stamp.

---

## The `upgrade` Subcommand

### CLI interface

```
npx @bradygaster/create-squad upgrade
```

No flags needed for v0.2. Future flags:

```
npx @bradygaster/create-squad upgrade --dry-run     # Show what would change
npx @bradygaster/create-squad upgrade --force        # Skip version check, re-apply everything
npx @bradygaster/create-squad upgrade --backup       # Create .ai-team-backup-{timestamp}/ first
```

### Argument parsing

Currently `index.js` has zero argument parsing. We add minimal routing:

```javascript
#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const GREEN = '\x1b[32m';
const YELLOW = '\x1b[33m';
const RED = '\x1b[31m';
const DIM = '\x1b[2m';
const BOLD = '\x1b[1m';
const RESET = '\x1b[0m';

const root = __dirname;
const dest = process.cwd();
const pkg = require(path.join(root, 'package.json'));
const SQUAD_VERSION = pkg.version;

const command = process.argv[2];

if (command === 'upgrade') {
  upgradeSquad();
} else if (command === 'export') {
  exportSquad();
} else if (command === 'import') {
  const file = process.argv[3];
  if (!file) {
    console.error(`${RED}Usage: create-squad import <file>${RESET}`);
    process.exit(1);
  }
  importSquad(file);
} else if (command === '--help' || command === '-h') {
  printHelp();
} else if (command === '--version' || command === '-v') {
  console.log(SQUAD_VERSION);
} else if (!command) {
  initSquad();
} else {
  console.error(`${RED}Unknown command: ${command}${RESET}`);
  console.error(`Run ${DIM}create-squad --help${RESET} for usage.`);
  process.exit(1);
}
```

This keeps everything in `index.js`. No dependency on `yargs`, `commander`, or anything else. Process.argv is enough for positional subcommands.

### The upgrade flow — step by step

```javascript
function upgradeSquad() {
  const installedVersion = detectInstalledVersion();

  if (!installedVersion) {
    console.error(`${RED}No Squad installation found.${RESET}`);
    console.error(`Run ${DIM}npx @bradygaster/create-squad${RESET} to install.`);
    process.exit(1);
  }

  if (installedVersion === SQUAD_VERSION) {
    console.log(`${GREEN}✓${RESET} Squad is already at v${SQUAD_VERSION}. Nothing to upgrade.`);
    return;
  }

  console.log(`${BOLD}Upgrading Squad${RESET} v${installedVersion} → v${SQUAD_VERSION}`);
  console.log();

  // Phase 1: Backup squad.agent.md (always — it's the one file we overwrite)
  const agentDest = path.join(dest, '.github', 'agents', 'squad.agent.md');
  if (fs.existsSync(agentDest)) {
    const backupPath = agentDest + `.v${installedVersion}.bak`;
    fs.copyFileSync(agentDest, backupPath);
    console.log(`${DIM}  backed up squad.agent.md → squad.agent.md.v${installedVersion}.bak${RESET}`);
  }

  // Phase 2: Overwrite squad.agent.md
  const agentSrc = path.join(root, '.github', 'agents', 'squad.agent.md');
  fs.mkdirSync(path.dirname(agentDest), { recursive: true });
  fs.copyFileSync(agentSrc, agentDest);
  console.log(`${GREEN}✓${RESET} .github/agents/squad.agent.md → v${SQUAD_VERSION}`);

  // Phase 3: Overwrite templates
  const templatesSrc = path.join(root, 'templates');
  const templatesDest = path.join(dest, '.ai-team-templates');
  copyRecursive(templatesSrc, templatesDest);
  console.log(`${GREEN}✓${RESET} .ai-team-templates/ → v${SQUAD_VERSION}`);

  // Phase 4: Create new directories/files that this version introduces
  const newDirs = getNewDirectories(installedVersion);
  for (const dir of newDirs) {
    const dirPath = path.join(dest, dir);
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
      console.log(`${GREEN}+${RESET} ${dir} ${DIM}(new in v${SQUAD_VERSION})${RESET}`);
    }
  }

  // Phase 5: Run version-specific migrations
  const migrations = getMigrations(installedVersion, SQUAD_VERSION);
  for (const migration of migrations) {
    try {
      migration.fn(dest);
      console.log(`${GREEN}✓${RESET} ${migration.description}`);
    } catch (err) {
      console.error(`${RED}✗${RESET} ${migration.description}: ${err.message}`);
      console.error(`${DIM}  Upgrade will continue. Fix this manually if needed.${RESET}`);
    }
  }

  // Phase 6: Write version metadata
  writeVersionMetadata(installedVersion);

  console.log();
  console.log(`${BOLD}Squad upgraded to v${SQUAD_VERSION}.${RESET}`);
  console.log();
  console.log(`${DIM}What changed:${RESET}`);
  console.log(`  • squad.agent.md — updated coordinator with new features`);
  console.log(`  • .ai-team-templates/ — updated format templates`);
  if (newDirs.length > 0) {
    console.log(`  • New directories created: ${newDirs.join(', ')}`);
  }
  if (migrations.length > 0) {
    console.log(`  • ${migrations.length} migration(s) applied`);
  }
  console.log();
  console.log(`${DIM}What's preserved:${RESET}`);
  console.log(`  • .ai-team/agents/ — all charters and histories untouched`);
  console.log(`  • .ai-team/decisions.md — team decisions untouched`);
  console.log(`  • .ai-team/casting/ — all casting state untouched`);
  console.log();
}
```

### Version metadata write

```javascript
function writeVersionMetadata(previousVersion) {
  const versionFile = path.join(dest, '.ai-team-templates', '.squad-version');
  let meta = {
    installed_version: SQUAD_VERSION,
    installed_at: new Date().toISOString(),
    upgraded_at: null,
    upgrade_history: []
  };

  if (fs.existsSync(versionFile)) {
    try {
      const existing = JSON.parse(fs.readFileSync(versionFile, 'utf8'));
      meta.installed_at = existing.installed_at || meta.installed_at;
      meta.upgrade_history = existing.upgrade_history || [];
    } catch (e) {
      // Start fresh if corrupted
    }
  }

  meta.upgraded_at = new Date().toISOString();
  meta.upgrade_history.push({
    from: previousVersion,
    to: SQUAD_VERSION,
    at: new Date().toISOString()
  });

  fs.writeFileSync(versionFile, JSON.stringify(meta, null, 2));
}
```

---

## Migration System

### Architecture

Migrations are functions keyed by version range. Each migration knows how to move state from one version to the next. They run in order, and each one is **idempotent** — running it twice produces the same result.

```javascript
const MIGRATIONS = [
  {
    from: '0.1.0',
    to: '0.2.0',
    description: 'Add Portable Knowledge section to agent histories',
    fn: migrate_0_1_to_0_2
  },
  {
    from: '0.2.0',
    to: '0.3.0',
    description: 'Add skills directory and preferences.md',
    fn: migrate_0_2_to_0_3
  }
];

function getMigrations(fromVersion, toVersion) {
  return MIGRATIONS.filter(m => {
    return compareVersions(m.from, fromVersion) >= 0
        && compareVersions(m.to, toVersion) <= 0;
  });
}

function compareVersions(a, b) {
  const pa = a.split('.').map(Number);
  const pb = b.split('.').map(Number);
  for (let i = 0; i < 3; i++) {
    if (pa[i] > pb[i]) return 1;
    if (pa[i] < pb[i]) return -1;
  }
  return 0;
}
```

### Example migration: v0.1 → v0.2

This adds the `## Portable Knowledge` / `## Project Learnings` sections to existing agent histories (per Proposal 008):

```javascript
function migrate_0_1_to_0_2(dest) {
  const agentsDir = path.join(dest, '.ai-team', 'agents');
  if (!fs.existsSync(agentsDir)) return;

  for (const agent of fs.readdirSync(agentsDir)) {
    const historyPath = path.join(agentsDir, agent, 'history.md');
    if (!fs.existsSync(historyPath)) continue;

    let content = fs.readFileSync(historyPath, 'utf8');

    // Idempotency: skip if already migrated
    if (content.includes('## Portable Knowledge')) continue;

    // Find the "## Learnings" section and split it
    const learningsMatch = content.match(
      /(## Learnings\s*\n<!-- .*? -->\s*\n)([\s\S]*)/
    );

    if (learningsMatch) {
      const header = learningsMatch[1];
      const existingLearnings = learningsMatch[2].trim();

      const newContent = content.replace(
        learningsMatch[0],
        '## Portable Knowledge\n\n' +
        '<!-- Observations about the USER that travel across projects. -->\n\n' +
        '## Project Learnings\n\n' +
        '<!-- Observations about THIS project\'s codebase, architecture, and decisions. -->\n\n' +
        (existingLearnings ? existingLearnings + '\n' : '')
      );

      fs.writeFileSync(historyPath, newContent);
    } else {
      // No "## Learnings" section — append the new sections at the end
      content += '\n\n## Portable Knowledge\n\n' +
        '<!-- Observations about the USER that travel across projects. -->\n\n' +
        '## Project Learnings\n\n' +
        '<!-- Observations about THIS project\'s codebase, architecture, and decisions. -->\n';
      fs.writeFileSync(historyPath, content);
    }
  }
}
```

### Example migration: v0.2 → v0.3

Hypothetical: v0.3 adds a `skills/` directory and a `preferences.md` per agent:

```javascript
function migrate_0_2_to_0_3(dest) {
  // Create skills directory
  const skillsDir = path.join(dest, '.ai-team', 'skills');
  if (!fs.existsSync(skillsDir)) {
    fs.mkdirSync(skillsDir, { recursive: true });
  }

  // Add preferences.md to each agent if it doesn't exist
  const agentsDir = path.join(dest, '.ai-team', 'agents');
  if (!fs.existsSync(agentsDir)) return;

  for (const agent of fs.readdirSync(agentsDir)) {
    const agentDir = path.join(agentsDir, agent);
    if (!fs.statSync(agentDir).isDirectory()) continue;

    const prefsPath = path.join(agentDir, 'preferences.md');
    if (!fs.existsSync(prefsPath)) {
      fs.writeFileSync(prefsPath,
        `# ${agent} — Portable Preferences\n\n` +
        `<!-- User preferences and conventions that travel across projects. -->\n`
      );
    }
  }
}
```

### Migration design principles

1. **Idempotent.** Every migration checks whether its work is already done before doing it. Running `upgrade` twice doesn't corrupt state.

2. **Non-destructive.** Migrations only add content. They never delete user data. If a section is being restructured, old content is preserved inside the new structure.

3. **Fault-tolerant.** If a migration fails, the upgrade continues. The user sees the error and can fix it manually. One broken history.md shouldn't abort the entire upgrade.

4. **Ordered.** Migrations run sequentially from the installed version to the target. Skipping versions is fine — each migration handles the delta independently.

5. **Windows-safe.** All paths go through `path.join()`. No hardcoded `/` or `\`. No symlinks. No shell commands. Pure `fs` operations.

---

## New Directory Registration

When a new version introduces new directories or files, they're registered in a simple map:

```javascript
function getNewDirectories(fromVersion) {
  const VERSION_DIRS = {
    '0.2.0': [
      // v0.2 doesn't add new dirs, just modifies existing files
    ],
    '0.3.0': [
      '.ai-team/skills'
    ]
  };

  const dirs = [];
  for (const [ver, verDirs] of Object.entries(VERSION_DIRS)) {
    if (compareVersions(ver, fromVersion) > 0) {
      dirs.push(...verDirs);
    }
  }
  return dirs;
}
```

---

## The Modified `initSquad()` Function

The existing init behavior is extracted into a function and enhanced to stamp the version:

```javascript
function initSquad() {
  // Copy agent file
  const agentSrc = path.join(root, '.github', 'agents', 'squad.agent.md');
  const agentDest = path.join(dest, '.github', 'agents', 'squad.agent.md');

  if (fs.existsSync(agentDest)) {
    console.log(`${DIM}squad.agent.md already exists — skipping${RESET}`);
    console.log(`${DIM}Run ${BOLD}create-squad upgrade${RESET}${DIM} to update to v${SQUAD_VERSION}${RESET}`);
  } else {
    fs.mkdirSync(path.dirname(agentDest), { recursive: true });
    fs.copyFileSync(agentSrc, agentDest);
    console.log(`${GREEN}✓${RESET} .github/agents/squad.agent.md`);
  }

  // Pre-create drop-box, orchestration-log, and casting directories
  const inboxDir = path.join(dest, '.ai-team', 'decisions', 'inbox');
  const orchLogDir = path.join(dest, '.ai-team', 'orchestration-log');
  const castingDir = path.join(dest, '.ai-team', 'casting');
  fs.mkdirSync(inboxDir, { recursive: true });
  fs.mkdirSync(orchLogDir, { recursive: true });
  fs.mkdirSync(castingDir, { recursive: true });

  // Copy templates
  const templatesSrc = path.join(root, 'templates');
  const templatesDest = path.join(dest, '.ai-team-templates');

  if (fs.existsSync(templatesDest)) {
    console.log(`${DIM}.ai-team-templates/ already exists — skipping${RESET}`);
    console.log(`${DIM}Run ${BOLD}create-squad upgrade${RESET}${DIM} to update templates${RESET}`);
  } else {
    copyRecursive(templatesSrc, templatesDest);
    console.log(`${GREEN}✓${RESET} .ai-team-templates/`);
  }

  // Write version metadata on fresh install
  const versionFile = path.join(dest, '.ai-team-templates', '.squad-version');
  if (!fs.existsSync(versionFile)) {
    const meta = {
      installed_version: SQUAD_VERSION,
      installed_at: new Date().toISOString(),
      upgraded_at: null,
      upgrade_history: []
    };
    fs.writeFileSync(versionFile, JSON.stringify(meta, null, 2));
  }

  console.log();
  console.log(`${BOLD}Squad is ready.${RESET} ${DIM}(v${SQUAD_VERSION})${RESET}`);
  console.log();
  console.log(`Next steps:`);
  console.log(`  1. Open Copilot:  ${DIM}copilot${RESET}`);
  console.log(`  2. Select ${BOLD}Squad${RESET} from the /agents list`);
  console.log(`  3. Tell it what you're building`);
  console.log();
}
```

Key change: When squad.agent.md already exists, the message now tells the user about `create-squad upgrade`. Previously it was a dead end.

---

## The Upgrade User Experience

### Scenario: User upgrades from v0.1.0 to v0.2.0

```
$ npx @bradygaster/create-squad upgrade

Upgrading Squad v0.1.0 → v0.2.0

  backed up squad.agent.md → squad.agent.md.v0.1.0.bak
✓ .github/agents/squad.agent.md → v0.2.0
✓ .ai-team-templates/ → v0.2.0
✓ Add Portable Knowledge section to agent histories

Squad upgraded to v0.2.0.

What changed:
  • squad.agent.md — updated coordinator with new features
  • .ai-team-templates/ — updated format templates
  • 1 migration(s) applied

What's preserved:
  • .ai-team/agents/ — all charters and histories untouched
  • .ai-team/decisions.md — team decisions untouched
  • .ai-team/casting/ — all casting state untouched
```

### Scenario: User runs upgrade when already current

```
$ npx @bradygaster/create-squad upgrade

✓ Squad is already at v0.2.0. Nothing to upgrade.
```

### Scenario: User runs init on an existing install

```
$ npx @bradygaster/create-squad

squad.agent.md already exists — skipping
Run create-squad upgrade to update to v0.2.0
.ai-team-templates/ already exists — skipping
Run create-squad upgrade to update templates

Squad is ready. (v0.2.0)

Next steps:
  1. Open Copilot:  copilot
  2. Select Squad from the /agents list
  3. Tell it what you're building
```

### Scenario: Upgrade fails mid-migration

```
$ npx @bradygaster/create-squad upgrade

Upgrading Squad v0.1.0 → v0.3.0

  backed up squad.agent.md → squad.agent.md.v0.1.0.bak
✓ .github/agents/squad.agent.md → v0.3.0
✓ .ai-team-templates/ → v0.3.0
✓ Add Portable Knowledge section to agent histories
+ .ai-team/skills (new in v0.3.0)
✗ Add skills directory and preferences.md: EPERM: operation not permitted, open '.ai-team\agents\keaton\preferences.md'
  Upgrade will continue. Fix this manually if needed.

Squad upgraded to v0.3.0.

What changed:
  • squad.agent.md — updated coordinator with new features
  • .ai-team-templates/ — updated format templates
  • New directories created: .ai-team/skills
  • 2 migration(s) applied
```

The upgrade doesn't abort on migration failure. The critical files (squad.agent.md, templates) are already updated. The migration that failed can be retried by running `upgrade --force` or fixed manually.

---

## Handling `squad.agent.md` Customizations

### The problem

What if the user has manually edited `squad.agent.md`? This could be anything from adding custom routing rules to adjusting the casting universe list. Overwriting it would destroy their changes.

### The reality

Users shouldn't customize `squad.agent.md`. It's a 32KB coordinator spec that defines Squad's behavior. Customizations here are fragile — they'll be overwritten on upgrade and they fight the intended orchestration model.

But users *will* customize it. Murphy's law.

### The solution

**Always back up before overwrite.** The backup goes to `squad.agent.md.v{old}.bak` right next to the original. If the user had customizations, they can diff the backup against the new version and re-apply.

```
.github/agents/
├── squad.agent.md              # ← new version (from upgrade)
└── squad.agent.md.v0.1.0.bak  # ← previous version (backup)
```

For v0.2, this is enough. The backup is there. The user can recover.

For v0.3+, consider:

```
$ npx @bradygaster/create-squad upgrade

⚠️  squad.agent.md has local modifications.
   Backed up to squad.agent.md.v0.1.0.bak
   Diff your backup against the new version to re-apply customizations:
     git diff --no-index .github/agents/squad.agent.md.v0.1.0.bak .github/agents/squad.agent.md
```

Detection: compare the installed `squad.agent.md` against the one that shipped with the installed version. If they differ, the user customized it. We can ship a hash of the expected content in `.squad-version`:

```json
{
  "installed_version": "0.1.0",
  "installed_at": "2026-02-08T14:30:00.000Z",
  "agent_md_hash": "a1b2c3d4..."
}
```

On upgrade, hash the current file and compare. If different → user customized → warn. If same → clean overwrite, no warning needed.

---

## Template Versioning

Templates are format guides that the coordinator reads when creating agent files. They're reference material, not user data.

### Strategy: Always overwrite

Templates are Squad-owned. Upgrade replaces all of them unconditionally. This is safe because:

1. Templates are only read by the coordinator during team creation
2. After team creation, the actual files in `.ai-team/` are what matter
3. Templates don't contain user state

New templates (added in a new version) are just new files in the `templates/` directory. The `copyRecursive` function handles them automatically.

### What about removed templates?

If a template is removed in a new version, the old copy stays in `.ai-team-templates/`. This is harmless — unused templates don't hurt anything. We don't need cleanup logic in v0.2.

If cleanup becomes important later, we can add a manifest of expected templates and remove files not in the manifest.

---

## The "No Sacred Tech Decisions" Angle

Brady said we can change anything. Here's how upgrade handles major format shifts:

### Case 1: Markdown to YAML for some files

If we move casting policy from JSON to YAML:

```javascript
{
  from: '0.4.0',
  to: '0.5.0',
  description: 'Migrate casting policy from JSON to YAML',
  fn: function(dest) {
    const jsonPath = path.join(dest, '.ai-team', 'casting', 'policy.json');
    if (!fs.existsSync(jsonPath)) return;

    const policy = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));
    // Convert to YAML (would need a dependency, or we do simple key-value)
    const yamlContent = jsonToSimpleYaml(policy);
    const yamlPath = path.join(dest, '.ai-team', 'casting', 'policy.yaml');

    fs.writeFileSync(yamlPath, yamlContent);
    // Keep the JSON file as backup, rename it
    fs.renameSync(jsonPath, jsonPath + '.pre-v0.5.bak');
  }
}
```

The old file is renamed, not deleted. The migration creates the new format. The coordinator spec (updated via squad.agent.md overwrite) knows to read the new format.

### Case 2: New agent roles

If a new version adds a "Security" role:

- Upgrade doesn't create the agent — that's the coordinator's job
- Upgrade updates `squad.agent.md` with the new role definition
- Upgrade updates templates so the coordinator has the right format
- Next time the user talks to Squad, the coordinator can offer to add the new role

### Case 3: squad.agent.md format changes significantly

This is the nuclear option. If the coordinator spec fundamentally changes:

1. Backup always happens (covered above)
2. The new `squad.agent.md` ships with the package
3. `upgrade` overwrites it
4. Migrations handle any `.ai-team/` state changes
5. The coordinator adapts on next session because it reads the spec fresh

The coordinator is stateless — it reads `squad.agent.md` from scratch every session. Changing the spec IS the upgrade. No running state to migrate.

---

## `package.json` Changes

### Minimal changes needed

```json
{
  "name": "@bradygaster/create-squad",
  "version": "0.2.0",
  "description": "Add an AI agent team to any project",
  "bin": {
    "create-squad": "./index.js"
  },
  "files": [
    "index.js",
    ".github/agents/squad.agent.md",
    "templates/**/*"
  ],
  "keywords": [
    "ai",
    "agents",
    "copilot",
    "squad",
    "team"
  ],
  "author": "bradygaster",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/bradygaster/squad"
  }
}
```

No new bin entry needed. `create-squad upgrade` is a subcommand handled by the existing `index.js` entrypoint. The `bin.create-squad` entry already maps to `./index.js`.

No new dependencies needed. The entire upgrade system uses `fs`, `path`, and `process.argv` — all built-in.

### Why not a separate bin entry?

A separate `create-squad-upgrade` would split the codebase and confuse users. The subcommand pattern (`create-squad upgrade`) is cleaner:

- Single entry point, single file
- `npx @bradygaster/create-squad upgrade` works immediately
- No PATH confusion between two binaries
- Consistent with `export` and `import` subcommands from Proposal 008

---

## Downgrade Story

### Can users downgrade? Should they be able to?

**No explicit downgrade command.** Here's why:

1. Downgrading `squad.agent.md` means reverting the coordinator to old behavior. The backup file (`squad.agent.md.v{x}.bak`) lets users do this manually if needed.

2. Downgrading templates is harmless — old templates work with new coordinators.

3. Downgrading migrations is dangerous — you'd need reverse migrations, which doubles the migration code and testing surface.

4. `npm install @bradygaster/create-squad@0.1.0` gets you the old CLI. But your `.ai-team/` state may have been migrated forward, and the old CLI won't know about new file structures.

**The practical answer:** If an upgrade goes wrong:

1. `squad.agent.md` has a backup → restore it
2. Templates are harmless → leave them
3. Migrations are additive → they don't break old behavior
4. The user can always `git checkout` to undo filesystem changes

This is the same model as database migrations. You can roll forward, not backward. Design migrations to be non-destructive so rollback isn't needed.

---

## Interaction with Proposal 008 (Portable Squads)

The `upgrade`, `export`, and `import` subcommands coexist cleanly:

```
npx create-squad              # Init — fresh install
npx create-squad upgrade      # Upgrade — update existing install
npx create-squad export       # Export — package squad for portability
npx create-squad import <f>   # Import — restore squad in new project
npx create-squad --help       # Help — show all commands
npx create-squad --version    # Version — show installed version
```

Upgrade and import are independent operations. Import creates a fresh install from a manifest. Upgrade updates an existing install. If someone imports and later upgrades, both code paths work correctly because they operate on the same file ownership model.

The one overlap: the `.squad-version` metadata file. Import should also write this file so that future upgrades know what version was imported:

```javascript
// In importSquad(), after all files are written:
writeVersionMetadata(null); // null previousVersion = fresh install via import
```

---

## Interaction with Proposal 007 (Tiered Response Modes)

If Proposal 007 changes `squad.agent.md` to support response tiers, those changes ship in the coordinator spec. Upgrade handles it automatically — `squad.agent.md` is always overwritten. No migration needed for coordinator-only changes.

---

## Error Handling

### What can go wrong and what we do about it

| Failure | Impact | Response |
|---------|--------|----------|
| `squad.agent.md` backup fails (EPERM) | Can't proceed safely | Abort upgrade with clear error |
| `squad.agent.md` overwrite fails | Coordinator stays on old version | Abort — tell user to check permissions |
| Template copy fails | Templates stale, but not critical | Continue — warn user |
| Migration fails | State partially updated | Continue — log error, tell user which migration failed |
| Version file write fails | Next upgrade can't detect version | Continue — use fallback detection next time |
| `.ai-team/` doesn't exist | Nothing to migrate | Skip migrations, just update Squad-owned files |

Critical failures (backup and overwrite of squad.agent.md) abort. Everything else continues with warnings. The user should never be left in a state where they can't use Squad.

```javascript
// Critical path — abort on failure
try {
  fs.copyFileSync(agentDest, backupPath);
} catch (err) {
  console.error(`${RED}✗ Failed to back up squad.agent.md: ${err.message}${RESET}`);
  console.error(`${RED}  Upgrade aborted. Your files are unchanged.${RESET}`);
  process.exit(1);
}

try {
  fs.copyFileSync(agentSrc, agentDest);
} catch (err) {
  // Attempt to restore backup
  try { fs.copyFileSync(backupPath, agentDest); } catch (_) { /* best effort */ }
  console.error(`${RED}✗ Failed to write squad.agent.md: ${err.message}${RESET}`);
  console.error(`${RED}  Upgrade aborted. Original file restored from backup.${RESET}`);
  process.exit(1);
}
```

---

## Implementation Plan

### Phase 1: Version stamping (v0.1.1 — patch release)

**Changes:**
1. Add `squad_version` to `squad.agent.md` frontmatter
2. Add `.squad-version` metadata file to init flow
3. Show version in init output (`Squad is ready. (v0.1.1)`)
4. When squad.agent.md exists, tell user about `upgrade`

**Effort:** ~1 hour. Zero risk. Backward compatible.

### Phase 2: Upgrade command (v0.2.0)

**Changes:**
1. Extract init into `initSquad()` function
2. Add argument routing (upgrade/export/import/help/version)
3. Implement `upgradeSquad()` with backup + overwrite + version write
4. Implement `detectInstalledVersion()` with three-strategy fallback
5. Implement migration framework + v0.1→v0.2 migration
6. Add `--help` output
7. Update `package.json` version

**Effort:** ~4 hours. This is the core of the proposal.

### Phase 3: Dry-run and backup flags (v0.2.1)

**Changes:**
1. `--dry-run` flag: list what would change without doing it
2. `--backup` flag: copy entire `.ai-team/` to `.ai-team-backup-{timestamp}/`
3. `--force` flag: skip version check, re-apply everything

**Effort:** ~2 hours. Quality-of-life features.

### Phase 4: Customization detection (v0.3.0)

**Changes:**
1. Store hash of `squad.agent.md` in `.squad-version`
2. On upgrade, detect if user modified squad.agent.md
3. Print diff hint if customized

**Effort:** ~1 hour. Nice-to-have, not critical.

### Total: ~8 hours across all phases.

---

## Complete `index.js` Sketch (v0.2.0)

For reference, here's the complete restructured `index.js` at ~140 lines. This is the full file, not a diff:

```javascript
#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const GREEN = '\x1b[32m';
const YELLOW = '\x1b[33m';
const RED = '\x1b[31m';
const DIM = '\x1b[2m';
const BOLD = '\x1b[1m';
const RESET = '\x1b[0m';

const root = __dirname;
const dest = process.cwd();
const pkg = require(path.join(root, 'package.json'));
const SQUAD_VERSION = pkg.version;

// --- Utilities ---

function copyRecursive(src, target) {
  if (fs.statSync(src).isDirectory()) {
    fs.mkdirSync(target, { recursive: true });
    for (const entry of fs.readdirSync(src)) {
      copyRecursive(path.join(src, entry), path.join(target, entry));
    }
  } else {
    fs.mkdirSync(path.dirname(target), { recursive: true });
    fs.copyFileSync(src, target);
  }
}

function compareVersions(a, b) {
  const pa = a.split('.').map(Number);
  const pb = b.split('.').map(Number);
  for (let i = 0; i < 3; i++) {
    if ((pa[i] || 0) > (pb[i] || 0)) return 1;
    if ((pa[i] || 0) < (pb[i] || 0)) return -1;
  }
  return 0;
}

function detectInstalledVersion() {
  const versionFile = path.join(dest, '.ai-team-templates', '.squad-version');
  if (fs.existsSync(versionFile)) {
    try {
      return JSON.parse(fs.readFileSync(versionFile, 'utf8')).installed_version;
    } catch (e) { /* fall through */ }
  }
  const agentFile = path.join(dest, '.github', 'agents', 'squad.agent.md');
  if (fs.existsSync(agentFile)) {
    const content = fs.readFileSync(agentFile, 'utf8');
    const match = content.match(/^squad_version:\s*"?([^"\n]+)"?/m);
    if (match) return match[1];
    return '0.1.0'; // pre-versioning install
  }
  return null;
}

function writeVersionMetadata(previousVersion) {
  const versionFile = path.join(dest, '.ai-team-templates', '.squad-version');
  let meta = {
    installed_version: SQUAD_VERSION,
    installed_at: new Date().toISOString(),
    upgraded_at: null,
    upgrade_history: []
  };
  if (fs.existsSync(versionFile)) {
    try {
      const existing = JSON.parse(fs.readFileSync(versionFile, 'utf8'));
      meta.installed_at = existing.installed_at || meta.installed_at;
      meta.upgrade_history = existing.upgrade_history || [];
    } catch (e) { /* start fresh */ }
  }
  if (previousVersion) {
    meta.upgraded_at = new Date().toISOString();
    meta.upgrade_history.push({ from: previousVersion, to: SQUAD_VERSION, at: meta.upgraded_at });
  }
  fs.writeFileSync(versionFile, JSON.stringify(meta, null, 2));
}

// --- Migrations ---

const MIGRATIONS = [
  // Add migrations here as versions progress
  // { from: '0.1.0', to: '0.2.0', description: '...', fn: migrate_0_1_to_0_2 }
];

function getMigrations(fromVersion, toVersion) {
  return MIGRATIONS.filter(m =>
    compareVersions(m.from, fromVersion) >= 0 && compareVersions(m.to, toVersion) <= 0
  );
}

function getNewDirectories(fromVersion) {
  const VERSION_DIRS = {};
  const dirs = [];
  for (const [ver, verDirs] of Object.entries(VERSION_DIRS)) {
    if (compareVersions(ver, fromVersion) > 0) dirs.push(...verDirs);
  }
  return dirs;
}

// --- Commands ---

function initSquad() {
  const agentSrc = path.join(root, '.github', 'agents', 'squad.agent.md');
  const agentDest = path.join(dest, '.github', 'agents', 'squad.agent.md');
  if (fs.existsSync(agentDest)) {
    console.log(`${DIM}squad.agent.md already exists — skipping${RESET}`);
    console.log(`${DIM}Run ${BOLD}create-squad upgrade${RESET}${DIM} to update to v${SQUAD_VERSION}${RESET}`);
  } else {
    fs.mkdirSync(path.dirname(agentDest), { recursive: true });
    fs.copyFileSync(agentSrc, agentDest);
    console.log(`${GREEN}✓${RESET} .github/agents/squad.agent.md`);
  }
  fs.mkdirSync(path.join(dest, '.ai-team', 'decisions', 'inbox'), { recursive: true });
  fs.mkdirSync(path.join(dest, '.ai-team', 'orchestration-log'), { recursive: true });
  fs.mkdirSync(path.join(dest, '.ai-team', 'casting'), { recursive: true });
  const templatesSrc = path.join(root, 'templates');
  const templatesDest = path.join(dest, '.ai-team-templates');
  if (fs.existsSync(templatesDest)) {
    console.log(`${DIM}.ai-team-templates/ already exists — skipping${RESET}`);
    console.log(`${DIM}Run ${BOLD}create-squad upgrade${RESET}${DIM} to update templates${RESET}`);
  } else {
    copyRecursive(templatesSrc, templatesDest);
    console.log(`${GREEN}✓${RESET} .ai-team-templates/`);
  }
  writeVersionMetadata(null);
  console.log();
  console.log(`${BOLD}Squad is ready.${RESET} ${DIM}(v${SQUAD_VERSION})${RESET}`);
  console.log();
  console.log(`Next steps:`);
  console.log(`  1. Open Copilot:  ${DIM}copilot${RESET}`);
  console.log(`  2. Select ${BOLD}Squad${RESET} from the /agents list`);
  console.log(`  3. Tell it what you're building`);
  console.log();
}

function upgradeSquad() {
  const installed = detectInstalledVersion();
  if (!installed) {
    console.error(`${RED}No Squad installation found.${RESET}`);
    console.error(`Run ${DIM}npx @bradygaster/create-squad${RESET} to install.`);
    process.exit(1);
  }
  if (installed === SQUAD_VERSION) {
    console.log(`${GREEN}✓${RESET} Squad is already at v${SQUAD_VERSION}. Nothing to upgrade.`);
    return;
  }
  console.log(`${BOLD}Upgrading Squad${RESET} v${installed} → v${SQUAD_VERSION}\n`);
  const agentDest = path.join(dest, '.github', 'agents', 'squad.agent.md');
  const backupPath = agentDest + `.v${installed}.bak`;
  try { fs.copyFileSync(agentDest, backupPath); }
  catch (err) {
    console.error(`${RED}✗ Backup failed: ${err.message}${RESET}`);
    process.exit(1);
  }
  console.log(`${DIM}  backed up squad.agent.md → squad.agent.md.v${installed}.bak${RESET}`);
  const agentSrc = path.join(root, '.github', 'agents', 'squad.agent.md');
  try { fs.copyFileSync(agentSrc, agentDest); }
  catch (err) {
    try { fs.copyFileSync(backupPath, agentDest); } catch (_) {}
    console.error(`${RED}✗ Overwrite failed: ${err.message}. Restored backup.${RESET}`);
    process.exit(1);
  }
  console.log(`${GREEN}✓${RESET} .github/agents/squad.agent.md → v${SQUAD_VERSION}`);
  copyRecursive(path.join(root, 'templates'), path.join(dest, '.ai-team-templates'));
  console.log(`${GREEN}✓${RESET} .ai-team-templates/ → v${SQUAD_VERSION}`);
  const newDirs = getNewDirectories(installed);
  for (const dir of newDirs) {
    const p = path.join(dest, dir);
    if (!fs.existsSync(p)) { fs.mkdirSync(p, { recursive: true }); console.log(`${GREEN}+${RESET} ${dir}`); }
  }
  const migrations = getMigrations(installed, SQUAD_VERSION);
  for (const m of migrations) {
    try { m.fn(dest); console.log(`${GREEN}✓${RESET} ${m.description}`); }
    catch (err) { console.error(`${RED}✗${RESET} ${m.description}: ${err.message}`); }
  }
  writeVersionMetadata(installed);
  console.log(`\n${BOLD}Squad upgraded to v${SQUAD_VERSION}.${RESET}\n`);
}

function printHelp() {
  console.log(`${BOLD}create-squad${RESET} v${SQUAD_VERSION}\n`);
  console.log(`Usage:`);
  console.log(`  create-squad              Create a new Squad in the current directory`);
  console.log(`  create-squad upgrade      Upgrade an existing Squad to v${SQUAD_VERSION}`);
  console.log(`  create-squad export       Export your Squad for portability`);
  console.log(`  create-squad import <f>   Import a Squad from a .squad file`);
  console.log(`  create-squad --version    Show version`);
  console.log(`  create-squad --help       Show this help\n`);
}

// --- Routing ---

const command = process.argv[2];
if (command === 'upgrade') upgradeSquad();
else if (command === 'export') { console.log(`${DIM}Export not yet implemented.${RESET}`); }
else if (command === 'import') { console.log(`${DIM}Import not yet implemented.${RESET}`); }
else if (command === '--help' || command === '-h') printHelp();
else if (command === '--version' || command === '-v') console.log(SQUAD_VERSION);
else if (!command) initSquad();
else { console.error(`${RED}Unknown command: ${command}${RESET}`); process.exit(1); }
```

---

## Success Criteria

1. **`npx create-squad upgrade` works on v0.1.0 installs.** Pre-versioning detection correctly identifies v0.1.0. Backup is created. squad.agent.md and templates are updated. Version metadata is written.

2. **User-owned files are never modified by upgrade.** Charters, histories, decisions, casting state — all preserved. Verified by checking file mtimes before and after.

3. **Migrations are idempotent.** Running upgrade twice produces the same result. No duplicate content. No corruption.

4. **Version detection is resilient.** Works with `.squad-version` metadata. Falls back to frontmatter parsing. Falls back to presence detection. Handles corrupted files gracefully.

5. **Windows paths work.** All file operations use `path.join()`. No hardcoded separators. Tested on Windows.

6. **Error handling is graceful.** Critical failures abort cleanly. Non-critical failures warn and continue. Users can always recover.

7. **Init hints at upgrade.** When squad.agent.md already exists during init, the user sees "Run create-squad upgrade to update."

---

## Open Questions

1. **Should upgrade be automatic?** When a user runs `npx @bradygaster/create-squad` on an existing project, should it auto-upgrade instead of skipping? Pro: frictionless. Con: surprising. My recommendation: no. Explicit `upgrade` subcommand. The init message hints at it.

2. **Should we add `.squad-version` to `.gitignore`?** It's metadata about the local install, not team state. But it's also useful for the team to know what version everyone is on. My recommendation: commit it. It's small and informative.

3. **Template diffing.** Should users be able to see what changed in templates? `create-squad upgrade --dry-run` could show a diff. But templates are reference material, not user config. My recommendation: `--dry-run` lists files that would be updated but doesn't show diffs.

4. **Lock file.** Should upgrade create a lock file to prevent concurrent upgrades? In practice, `npx create-squad upgrade` is a manual command. Two users running it simultaneously on the same repo is a git merge problem, not a Squad problem. My recommendation: no lock file.

5. **Notification of available upgrades.** Should Squad tell users when a new version is available? This would require an npm registry check at init/run time. My recommendation: no. Respect offline environments. Users can check npm themselves.

---

**Review requested from:** Keaton (architecture fit), Kujan (platform constraints), Hockney (testing the upgrade path), bradygaster (product sign-off)  
**Approved by:** [Pending]  
**Implemented:** [Pending]  
**Retrospective:** [Pending]
