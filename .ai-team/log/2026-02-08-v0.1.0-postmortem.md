# v0.1.0 Postmortem: The State Leak

**Date:** 2026-02-08
**Author:** Verbal (Prompt Engineer)
**Severity:** Moderate — GitHub visibility leak, no npm distribution impact
**Status:** Resolved

---

## Summary

We shipped our internal brain to the public internet.

When we merged `dev` → `main` for the v0.1.0 release, 63 files of `.ai-team/` state — charters, agent histories, team decisions, casting state, session logs — went live on the public GitHub repo at `github.com/bradygaster/squad`. Alongside it: 30+ proposals, blog drafts, demo scripts, and old template files from `docs/` and `.ai-team-templates/`.

The saving grace: `package.json`'s `files` allowlist meant none of this ever reached npm consumers. Anyone running `npx create-squad` got clean product files only. But anyone browsing the GitHub repo could read our entire team's internal planning, decision history, and agent state.

We caught it. We fixed it. We built three layers of protection so it never happens again.

---

## Timeline

1. **v0.1.0 tagged and released** — `dev` merged to `main`, release tag cut
2. **State leak discovered** — `.ai-team/` directory (63 files) visible on public GitHub repo alongside `docs/`, `.ai-team-templates/`
3. **Impact assessed** — `package.json` `files` array confirmed as allowlist; npm distribution was clean. Damage limited to GitHub visibility
4. **Fix applied:**
   - Added `.ai-team/`, `docs/`, `.ai-team-templates/` to `.gitignore`
   - Ran `git rm -r --cached .ai-team/` to remove from index (kept on disk)
   - Ran `git rm -r docs/ .ai-team-templates/` to remove internal planning docs
   - Merged fix to `main`, synced `dev`, synced `wave-2`
5. **The gotcha** — When the fix merged into `dev`, git deleted `.ai-team/` from disk. Why? `dev` was tracking those files, and the merge removed them from the index. Git interpreted "no longer tracked" as "delete." Had to restore: `git checkout 67b48c8 -- .ai-team/` then `git reset HEAD .ai-team/`
6. **Protections established** — Three-layer defense plus new branch strategy

---

## Impact

| Vector | Impact | Details |
|--------|--------|---------|
| **npm consumers** | ✅ None | `package.json` `files` allowlist blocked all non-product files |
| **GitHub viewers** | ⚠️ Moderate | Internal team state, planning docs, proposals visible on public repo |
| **Security** | ✅ None | No secrets, credentials, or sensitive data in leaked files |
| **Product integrity** | ✅ None | Product files shipped correctly; installer worked as designed |

The `package.json` `files` array was already correct — it's an allowlist that only includes product files. This is the single decision that prevented the worst outcome. If we'd been using an exclusion pattern (`.npmignore` only), the team state would have shipped to every `npx` consumer.

---

## Root Cause

**`.ai-team/` was tracked in git on the `dev` branch.**

That's it. That's the whole root cause.

`.ai-team/` is runtime state — it's created when a user runs `npx create-squad`, populated by agent work, and specific to that user's project. It should never have been committed. But we were using our own product to build our own product (eating our own dogfood), and the team state accumulated on `dev` naturally. Nobody thought to `.gitignore` it before the first release because `.ai-team/` didn't exist when the repo was created — it was born during development.

Same story for `docs/` (proposals, blog drafts, demo scripts) and `.ai-team-templates/` (old template copies). These are dev-branch artifacts, not product files.

---

## Fix

### Immediate

```bash
# Stop tracking team state
echo ".ai-team/" >> .gitignore
echo "docs/" >> .gitignore
echo ".ai-team-templates/" >> .gitignore

# Remove from git index (keep on disk)
git rm -r --cached .ai-team/

# Remove internal docs entirely from tracked files
git rm -r docs/ .ai-team-templates/

# Commit and push
git commit -m "Remove internal state and planning docs from tracking"
git push
```

### The Merge Gotcha

When this fix merged into `dev`, git deleted `.ai-team/` from disk. This is correct git behavior — `dev` was tracking those files, the incoming merge said "these files are removed from the index," and git obliged by removing them from the working tree.

Recovery:
```bash
git checkout 67b48c8 -- .ai-team/   # Restore files from last commit that had them
git reset HEAD .ai-team/              # Unstage (so they stay untracked)
```

**Lesson:** When you stop tracking files that are tracked on another branch, merging that change INTO the other branch will delete them from disk. Always have a backup or know which commit to restore from.

---

## Prevention: Three-Layer Defense

### Layer 1: `.gitignore`
```
.ai-team/
docs/
.ai-team-templates/
```
Prevents `git add` from ever tracking these directories again. First line of defense.

### Layer 2: `package.json` `files` allowlist
```json
{
  "files": [
    "index.js",
    "templates/**",
    "README.md",
    "LICENSE",
    "CHANGELOG.md"
  ]
}
```
Only these files ship to npm. Everything else is excluded by default. This is what saved us — even when `.ai-team/` was tracked in git, it never reached npm consumers.

### Layer 3: `.npmignore`
```
.ai-team/
.ai-team-templates/
docs/
```
Explicit exclusion as a belt-and-suspenders backup to the `files` allowlist.

### Layer 4: Branch Strategy
```
dev → release → main
```
New `release` branch serves as a staging gate. `main` contains ONLY product files (24 files total). Nothing merges to `main` without passing through `release` first.

---

## Main Branch — Final State

After cleanup, `main` contains exactly 24 files:

```
.gitattributes
.github/agents/squad.agent.md
.github/workflows/ci.yml
.github/workflows/release.yml
.gitignore
.npmignore
CHANGELOG.md
LICENSE
README.md
index.js
package.json
templates/* (12 files)
test/index.test.js
```

Nothing else. No planning docs. No team state. No templates that aren't product templates. This is what "main = bare minimum product" looks like.

---

## Learnings

### 1. Runtime state is not source code

`.ai-team/` is created by the product at runtime. It belongs to the user, not the repo. Tracking it in git is like committing `node_modules/` — it works on your machine, it breaks the pattern for everyone else.

**Rule:** If a file is created by running your product, it goes in `.gitignore`. No exceptions.

### 2. The `files` allowlist is your last defense

npm's `files` field in `package.json` is an allowlist. Only listed files ship. This is strictly better than `.npmignore` (a denylist) because it fails safe — if you forget to add something, it doesn't ship. If you forget to exclude something from `.npmignore`, it does.

**Rule:** Always use `files` in `package.json`. Never rely solely on `.npmignore`.

### 3. Eating your own dogfood creates invisible state

We used Squad to build Squad. That's great for product validation. But it means `.ai-team/` accumulated naturally in our working tree, and because we were always on `dev`, nobody noticed it was tracked. The state was invisible because it was *ours* — we expected it to be there.

**Rule:** Before any release, run `git ls-files | grep -v "^templates/"` and ask: "Would I want a stranger to see every one of these files?"

### 4. The merge gotcha is a real trap

When you `git rm --cached` a file and merge that change into a branch that's still tracking the file, git will delete the file from disk. This is correct behavior (the merge says "this file should no longer exist in the working tree"), but it's surprising if you expected `--cached` to mean "keep the file forever."

**Rule:** Before merging a "stop tracking" change into another branch, know which commit you can restore from. Better yet: copy the files to a temp location first.

### 5. Multi-agent teams generate MORE state than you think

A single Squad session can produce: agent histories, decisions, decision inbox files, session logs, orchestration logs, casting state, and skills files. Our `.ai-team/` had 63 files after just two days of active development. At scale, this grows fast. Any team using Squad will face this exact pattern — the `.ai-team/` directory will accumulate state, and if it's tracked in git, it WILL leak on the first public push.

**Rule for Squad users:** Add `.ai-team/` to your `.gitignore` IMMEDIATELY after running `npx create-squad`. Don't wait. Don't think "I'll do it later." Do it now.

---

## What This Means for Multi-Agent State Management

Here's the bigger picture, and this is where I put on the AI strategist hat.

Every multi-agent system in the industry is going to face this problem. The moment you give agents persistent memory — histories, decisions, learned skills, team state — you create a new category of data that doesn't fit neatly into "source code" or "build artifacts." It's **team state**: the accumulated knowledge of your AI collaborators.

Team state has properties that make it tricky:
- **It's valuable** — you don't want to lose it (it represents hours of agent work)
- **It's private** — it contains internal planning, opinions, and decision rationale
- **It's runtime-generated** — it doesn't exist when you clone the repo
- **It looks like source code** — it's markdown files in your repo directory

That last point is the trap. Because `.ai-team/` lives in your project directory and contains `.md` files, it *feels* like it should be tracked. Your IDE shows it. `git status` shows it. `git add .` catches it. Every instinct says "commit this." And every instinct is wrong.

Squad's filesystem-backed memory is a feature — it's human-readable, git-cloneable, and transparent. But that same transparency means it's one `git add .` away from being public. The three-layer defense we built today (`.gitignore` + `files` allowlist + `.npmignore`) is the minimum viable protection for any tool that stores agent state in the project directory.

**Prediction:** Every multi-agent framework that stores state in the filesystem will ship a version that accidentally leaks that state. We just did it on day one. Others will do it at scale. The teams that build state hygiene into their product early will avoid the painful version of this lesson.

We got lucky. The `files` allowlist caught the worst case. But luck isn't a strategy. Three layers of defense is.

---

## Final Note

This is the kind of incident that bonds a team. Not because it was fun — it wasn't — but because it tested whether we could catch a mistake, fix it under pressure, and build protection so it never happens again. We did all three.

The irony isn't lost on me: an AI team-building tool leaked its own AI team's state. If that's not a lesson in dogfooding, I don't know what is.

Ship it. Learn from it. Move on.

— Verbal
